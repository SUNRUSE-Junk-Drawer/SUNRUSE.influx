# Given:
#	The tokenized functions.
#	The input value object.
#	An expression object.
#	The function containing the expression.
#	Optionally, an array of strings.  This will be written to log attempts to
#		match functions.
#	When the fourth argument is given, a prefix to prepend onto to log lines
#		generated by child expressions and functions.
# Returns:
#	When the expression does not compile, falsy.
#	When the expression compiles, the value object generated is returned.
module.exports = (tokenized, input, expression, funct, log, logPrefix) ->
	if expression.chain
		if log
			chain = []
			for token in expression.chain
				chain.push token.token
			log.push logPrefix + "Attempting to compile chain \"" + (chain.join " ") + "\"..."
		value = module.exports.getValue tokenized, input, expression.chain[0].token, funct, log, logPrefix + "\t"
		for func in [1 ... expression.chain.length]
			if not value then return null
			value = module.exports.findFunction tokenized, value, expression.chain[func].token, log, logPrefix + "\t"
		if log and value
			log.push logPrefix + "\tSuccessfully compiled chain."
		value
	else
		output =
			score: 0 
			properties: {}
		if log
			log.push logPrefix + "Attempting to compile properties " + ((Object.keys expression.properties).join ", ") + "..."
		for property of expression.properties
			if log
				log.push logPrefix + "Attempting to compile property \"" + property + "\"..."
			value = module.exports.compileExpression tokenized, input, expression.properties[property], funct, log, logPrefix + "\t"
			if not value then return null
			output.properties[property] = value
			output.score += value.score
		if log
			log.push logPrefix + "\tSuccessfully compiled all properties with a total score of " + output.score + "."			
		output
	
module.exports.getValue = require "./getValue"
module.exports.findFunction = require "./findFunction"
module.exports.compileExpression = module.exports