# Given:
#	The tokenized functions.
#	The value object to take as an input.
#	The name of the function to resolve.
#	Optionally, an array of strings.  This will be written to log attempts to
#		match functions.
#	When the fourth argument is given, a prefix to prepend onto to log lines
#		generated by child expressions and functions.
# Returns:
#	If the value has properties and the function name matches one of those 
#	properties:
#		score: 1
#		value: The property named in the value object.
#	If no matching function compiled, falsy.
#	If functions matched, the value object returned by the highest scoring function,
#	whether native or otherwise.
module.exports = (tokenized, input, name, log, logPrefix) ->
	if log
		log.push logPrefix + "Attempting to find a match for function \"" + name + "\"..."
	if input.properties and input.properties[name]
		if log
			log.push logPrefix + "\tUsing the property of the input with a score of " + input.properties[name].score + "."
		input.properties[name]
	else
		best = []
		bestScore = null
		handleValue = (value, origin) ->
			if value
				if log
					log.push logPrefix + "\t\tSuccessfully compiled with a score of " + value.score + "."
				if not bestScore or value.score > bestScore
					bestScore = value.score
					best = [
						value: value
						origin: origin
					]
				else if value.score is bestScore
					best.push 
						value: value
						origin: origin
			else if log
				log.push logPrefix + "\t\tThis implementation did not compile."
					
		for id of tokenized.functions
			implementation = tokenized.functions[id]
			if implementation.name isnt name then continue
			if log
				log.push logPrefix + "\tTrying implementation in file \"" + implementation.line.filename + "\" on line " + implementation.line.line + "..."			
			handleValue (module.exports.compileExpression tokenized, input, implementation.declarations.output, implementation, log, logPrefix + "\t\t"), implementation					
					
		for id of tokenized.nativeFunctions
			implementation = tokenized.nativeFunctions[id]
			if implementation.name isnt name then continue
			if log
				log.push logPrefix + "\tTrying native implementation returning primitive type \"" + implementation.output + "\"..." 
			handleValue (implementation.compile input, log, logPrefix + "\t\t"), implementation

		if log
			if best.length
				if best[0].origin.line
					log.push logPrefix + "\tSelected the implementation in file \"" + best[0].origin.line.filename + "\" on line " + best[0].origin.line.line + " which scored " + best[0].value.score + "."
				else
					log.push logPrefix + "\tSelected the native implementation returning primitive type \"" + best[0].origin.output + "\" which scored " + best[0].value.score + "."
			else
				log.push logPrefix + "\tNo matches were found."
		best[0]?.value
	
module.exports.compileExpression = require "./compileExpression"